Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

src/
├── app.rs
├── config.rs
├── error.rs
├── lib.rs
├── main.rs
├── services
│   ├── api.rs
│   └── image.rs
├── services.rs
└── types.rs

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] app.rs
use crate::{AppError, ImageProcessor, VisionApiClient};

#[derive(Default)]
pub struct App {
    api_client: VisionApiClient,
}

impl App {
    pub fn new() -> Self {
        Self::default()
    }

    pub async fn process_image(&self, image_path: &str) -> Result<String, AppError> {
        let base64_image = ImageProcessor::to_base64(image_path)?;
        self.api_client.analyze_image(base64_image).await
    }
}

[File Ends] app.rs

[File Begins] config.rs
use dotenv::dotenv;
use std::env;

pub struct Config {
    pub api_url: String,
    pub model_name: String,
    pub prompt: String,
}

impl Config {
    pub fn build() -> Result<Self, env::VarError> {
        const DEFAULT_API_URL: &str = "http://ollama.local/api/generate";
        const DEFAULT_MODEL_NAME: &str = "llama3.2-vision";
        const DEFAULT_PROMPT: &str = "
            Analyze this image in detail and provide a comprehensive description in the following format:

            Primary subject/focus (1-2 sentences describing the main subject)
            Visual characteristics:

            Colors (dominant and accent colors)
            Lighting conditions and atmosphere
            Composition and framing

            Contextual details:

            Setting/background
            Time of day/season (if applicable)
            Notable objects or elements

            Technical aspects:

            Image quality
            Perspective/angle
            Any distinctive photographic techniques

            Semantic tags: [list 5-7 key descriptive tags]

            Finally, provide a concise, information-dense prompt (2-3 sentences) that captures the most distinctive and searchable aspects of this image.
        ";

        dotenv().ok();
        let api_url = env::var("API_URL").unwrap_or_else(|_| DEFAULT_API_URL.to_string());
        let model_name = env::var("MODEL_NAME").unwrap_or_else(|_| DEFAULT_MODEL_NAME.to_string());
        let prompt = env::var("PROMPT").unwrap_or_else(|_| DEFAULT_PROMPT.to_string());

        Ok(Self {
            api_url,
            model_name,
            prompt,
        })
    }
}

[File Ends] config.rs

[File Begins] error.rs
use thiserror::Error;

#[derive(Debug, Error)]
pub enum AppError {
    #[error("API error: {0}")]
    Api(String),
    #[error("Request failed: {0}")]
    Request(#[from] reqwest::Error),
    #[error("File error: {0}")]
    File(#[from] std::io::Error),
    #[error("Base64 encoding error: {0}")]
    Encoding(#[from] base64::DecodeError),
}

[File Ends] error.rs

[File Begins] lib.rs
mod app;
mod config;
mod error;
mod services;
mod types;

pub use app::App;
pub use config::*;
pub use error::*;
pub use services::*;
pub use types::*;

[File Ends] lib.rs

[File Begins] main.rs
use embex::App;

#[tokio::main]
async fn main() {
    let app = App::new();

    match app.process_image("image.png").await {
        Ok(response) => println!("Analysis result: {response}"),
        Err(e) => eprintln!("Error: {e}"),
    }
}

[File Ends] main.rs

  [File Begins] services/api.rs
  use crate::{
      config,
      error::AppError,
      types::{ApiErrorResponse, ApiRequest, ApiResponse},
  };
  use reqwest::Client;
  use std::io::{Error, ErrorKind};
  
  #[derive(Default)]
  pub struct VisionApiClient {
      client: Client,
  }
  
  impl VisionApiClient {
      pub fn new() -> Self {
          Self::default()
      }
  
      pub async fn analyze_image(&self, image_base64: String) -> Result<String, AppError> {
          let config = config::Config::build().map_err(|e| {
              eprintln!("Configuration error: {}", e);
              Error::new(ErrorKind::Other, e)
          })?;
  
          let request = ApiRequest {
              model: config.model_name,
              prompt: config.prompt,
              stream: false,
              images: vec![image_base64],
          };
  
          let response = self
              .client
              .post(config.api_url)
              .json(&request)
              .send()
              .await?;
  
          if response.status().is_success() {
              let success: ApiResponse = response.json().await?;
              Ok(success.response)
          } else {
              let error: ApiErrorResponse = response.json().await?;
              Err(AppError::Api(error.error))
          }
      }
  }
  
  // Need to write Unit tests

  [File Ends] services/api.rs

  [File Begins] services/image.rs
  use crate::error::AppError;
  use base64::{engine::general_purpose::STANDARD, Engine};
  use std::fs;
  
  pub struct ImageProcessor;
  
  impl ImageProcessor {
      pub fn to_base64(path: &str) -> Result<String, AppError> {
          let bytes = fs::read(path)?;
          Ok(STANDARD.encode(bytes))
      }
  }
  
  #[cfg(test)]
  mod tests {
      use super::*;
      use std::io::Write;
      use tempfile::NamedTempFile;
  
      #[test]
      fn test_image_to_base64() {
          // Create a temporary test file
          let mut temp_file = NamedTempFile::new().unwrap();
          temp_file.write_all(b"test image content").unwrap();
  
          let result = ImageProcessor::to_base64(temp_file.path().to_str().unwrap());
          assert!(result.is_ok());
  
          // Known base64 of "test image content"
          let expected = STANDARD.encode(b"test image content");
          assert_eq!(result.unwrap(), expected);
      }
  
      #[test]
      fn test_image_to_base64_nonexistent_file() {
          let result = ImageProcessor::to_base64("nonexistent.png");
          assert!(result.is_err());
          assert!(matches!(result.unwrap_err(), AppError::File(_)));
      }
  }

  [File Ends] services/image.rs

[File Begins] services.rs
pub mod api;
pub mod image;

pub use self::api::VisionApiClient;
pub use self::image::ImageProcessor;

[File Ends] services.rs

[File Begins] types.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize)]
pub struct ApiResponse {
    pub response: String,
}

#[derive(Debug, Deserialize)]
pub struct ApiErrorResponse {
    pub error: String,
}

#[derive(Debug, Serialize)]
pub struct ApiRequest {
    pub model: String,
    pub prompt: String,
    pub stream: bool,
    pub images: Vec<String>,
}

[File Ends] types.rs


<-- File Content Ends

